use std::env;
use std::ffi::OsStr;
use std::io::BufReader;
use std::path::PathBuf;
use std::process::{Command, Stdio};

use anyhow::anyhow;
use cargo_metadata::{Message, Version};
use clap::Args;
use embuild::utils::CmdError;

#[derive(Debug, thiserror::Error)]
pub enum BuildError {
    #[error("failed to get metadata of the crate")]
    NoMetadata(#[source] cargo_metadata::Error),

    #[error("could not determine the root crate")]
    NoRootCrate,

    #[error("dependency `esp-idf-sys` not found")]
    EspIdfSysNotFound(#[source] Option<anyhow::Error>),

    #[error("`cargo build` failed")]
    CargoBuildFailed(#[source] embuild::utils::CmdError),

    #[error("communication with cargo failed")]
    CargoMsgError(#[source] std::io::Error),
}

#[derive(Debug, Args)]
#[clap(help_heading = "BUILD OPTIONS")]
pub struct BuildOpts {
    #[clap(flatten)]
    manifest: clap_cargo::Manifest,
    #[clap(flatten)]
    features: clap_cargo::Features,
    /// Build with release profile
    #[clap(long)]
    release: bool,
}

pub struct BuildInfo {
    /// The path of the built executable
    pub bin_path: Option<PathBuf>,
    pub esp_idf_sys_out_dir: PathBuf,
    pub esp_idf_sys_version: Version,
}

/// Run `cargo build` in the current directory.
///
/// And get the path to the built binary and the path to the `esp-idf-build.json`
/// generated by the `esp-idf-sys` build script.
pub fn run(opts: BuildOpts) -> Result<BuildInfo, BuildError> {
    // Get metadata to determine package-ids of the root package and esp-idf-sys.
    let meta = opts
        .features
        .forward_metadata(&mut opts.manifest.metadata())
        .exec()
        .map_err(BuildError::NoMetadata)?;

    let root = meta.root_package().ok_or(BuildError::NoRootCrate)?.clone();

    let esp_idf_sys = meta
        .packages
        .iter()
        .find(|p| p.name == "esp-idf-sys")
        .ok_or(BuildError::EspIdfSysNotFound(None))?
        .clone();
    drop(meta);

    // Build the crate
    let mut cmd = Command::new(env::var_os("CARGO").unwrap_or_else(|| "cargo".into()));
    cmd.args(&["build", "--message-format=json-diagnostic-rendered-ansi"])
        .stdout(Stdio::piped())
        .stderr(Stdio::inherit());
    if let Some(ref manifest) = opts.manifest.manifest_path {
        cmd.args([OsStr::new("--manifest-path"), manifest.as_os_str()]);
    }
    if opts.features.all_features {
        cmd.arg("--all-features");
    }
    if opts.features.no_default_features {
        cmd.arg("--no-default-features");
    }
    if opts.release {
        cmd.arg("--release");
    }
    if !opts.features.features.is_empty() {
        cmd.args(&["--features", &opts.features.features.join(",")]);
    }
    log::debug!("Running {:?}", cmd);
    let mut process = match cmd.spawn() {
        Err(e) => return Err(BuildError::CargoBuildFailed(CmdError::no_run(&cmd, e))),
        Ok(p) => p,
    };

    let reader = BufReader::new(process.stdout.take().unwrap());

    let mut esp_idf_sys_out_dir = None;
    let mut bin_path = None;

    for message in Message::parse_stream(reader) {
        let message = message.map_err(BuildError::CargoMsgError)?;
        log::trace!("{:?}", message);
        match message {
            Message::CompilerMessage(msg) => {
                println!("{}", msg);
            }
            Message::CompilerArtifact(artifact) => {
                // Get the path to the final binary
                if bin_path.is_none() && artifact.package_id == root.id {
                    bin_path = artifact.filenames.into_iter().next();
                }
            }
            Message::BuildScriptExecuted(script) => {
                // Get the out dir for esp-idf-sys
                if esp_idf_sys_out_dir.is_none() && script.package_id == esp_idf_sys.id {
                    esp_idf_sys_out_dir = Some(script.out_dir);
                }
            }
            Message::BuildFinished(_) => (),
            _ => (),
        }
    }
    CmdError::status_into_result(
        process
            .wait()
            .map_err(|err| BuildError::CargoBuildFailed(CmdError::no_run(&cmd, err)))?,
        &cmd,
        || None,
    )
    .map_err(BuildError::CargoBuildFailed)?;

    let esp_idf_sys_out_dir = esp_idf_sys_out_dir
        .ok_or_else(|| BuildError::EspIdfSysNotFound(Some(anyhow!("Failed to get out dir"))))?
        .into_std_path_buf();

    Ok(BuildInfo {
        bin_path: bin_path.map(Into::into),
        esp_idf_sys_out_dir,
        esp_idf_sys_version: esp_idf_sys.version,
    })
}
